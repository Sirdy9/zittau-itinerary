const CACHE_NAME = 'zittau-pwa-v1';
const TILE_CACHE_NAME = 'zittau-tile-v1';
// Resources to precache for offline use.  Include the HTML, manifest, icons
// and the external QR code library so it works offline.  The icon file
// generated by the assistant (ffbd7782-...) is not strictly needed but
// caching it avoids network requests if referenced elsewhere.
const PRECACHE_ASSETS = [
  './index.html',
  './manifest.json',
  './icon-192.png',
  './icon-512.png',
  './091e1c8f-1995-418e-8bdb-f31e916fc16f.png',
  // Externí knihovny pro offline použití (QR code a komprese)
  'https://unpkg.com/qrcodejs@1.0.0/qrcode.min.js',
  'https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js'
];

self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME).then(cache => {
      return cache.addAll(PRECACHE_ASSETS);
    })
  );
  self.skipWaiting();
});

self.addEventListener('activate', event => {
  event.waitUntil(self.clients.claim());
});

// Flag to control offline-only mode, set via postMessage from the page.
let offlineMode = false;
self.addEventListener('message', event => {
  if (event.data && event.data.type === 'SET_OFFLINE_MODE') {
    offlineMode = event.data.enabled;
  }
});

/**
 * Intercept fetch requests. Tile requests are cached separately so that the
 * user can browse the map offline. All other requests use a network-first
 * strategy with a cache fallback for offline scenarios. If offlineMode is
 * enabled, cached responses are used whenever available.
 */
self.addEventListener('fetch', event => {
  const request = event.request;
  const url = new URL(request.url);
  // Cache tile requests separately
  if (/tile\.openstreetmap\.org|basemaps\.cartocdn\.com/.test(url.hostname)) {
    event.respondWith(
      caches.open(TILE_CACHE_NAME).then(cache => {
        return cache.match(request).then(cached => {
          if (cached && offlineMode) {
            return cached;
          }
          return fetch(request)
            .then(response => {
              if (response.status === 200) {
                cache.put(request, response.clone());
              }
              return response;
            })
            .catch(() => cached);
        });
      })
    );
    return;
  }
  // Other requests: network first, fallback to cache
  event.respondWith(
    caches.open(CACHE_NAME).then(cache => {
      return fetch(request)
        .then(response => {
          if (response.status === 200 && request.method === 'GET') {
            cache.put(request, response.clone());
          }
          return response;
        })
        .catch(() => {
          return cache.match(request);
        });
    })
  );
});
